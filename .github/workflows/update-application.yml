name: Update Application (Reusable)

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name'
        required: true
        type: string
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      branch:
        description: 'Branch to update'
        required: false
        type: string
        default: 'snapshot'
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      descriptor_build_offset:
        description: 'Offset to apply to application artifact version'
        required: false
        type: string
        default: '100100000000000'
      pre_release:
        description: 'Pre-release modules (only | true | false)'
        required: false
        type: string
        default: 'only'
      is_release_flow:
        description: 'Whether this is a release flow (affects version calculation)'
        required: false
        type: boolean
        default: false
    outputs:
      updated:
        description: 'Whether application was updated'
        value: ${{ jobs.update-application.outputs.updated }}
      previous_version:
        description: 'Previous application version'
        value: ${{ jobs.update-application.outputs.previous_version }}
      new_version:
        description: 'New application version if updated'
        value: ${{ jobs.update-application.outputs.new_version }}
      updates_cnt:
        description: 'Number of updated modules'
        value: ${{ jobs.update-application.outputs.updates_cnt }}
      updated_modules:
        description: 'List of updated modules'
        value: ${{ jobs.update-application.outputs.updated_modules }}
      app_descriptor_file:
        description: 'Generated application descriptor file path'
        value: ${{ jobs.update-application.outputs.app_descriptor_file }}
      app_descriptor_file_name:
        description: 'Name of generated application descriptor file'
        value: ${{ jobs.update-application.outputs.app_descriptor_file_name }}
      failure_reason:
        description: 'Reason for failure'
        value: ${{ jobs.update-application.outputs.failure_reason }}

permissions:
  contents: read

env:
  STATE_FILE: "application-descriptor.json"
  APP_NAME: ${{ inputs.app_name }}
  FOLIO_REGISTRY: "https://folio-registry.dev.folio.org/_/proxy/modules?latest=10&order=desc&orderBy=id&filter="

jobs:
  update-application:
    name: Update Application
    runs-on: ubuntu-latest
    outputs:
      updated_modules: ${{ steps.update-module-versions.outputs.updated_modules }}
      updated: ${{ steps.update-module-versions.outputs.updated }}
      updates_cnt: ${{ steps.update-module-versions.outputs.updates }}
      previous_version: ${{ steps.update-application-version.outputs.previous_version }}
      new_version: ${{ steps.update-application-version.outputs.new_version }}
      app_descriptor_file: ${{ steps.generate-application-descriptor.outputs.app_descriptor_file }}
      app_descriptor_file_name: ${{ steps.generate-application-descriptor.outputs.app_descriptor_file_name }}
      failure_reason: ${{ steps.update-module-versions.outputs.failure_reason || 
        steps.generate-application-descriptor.outputs.failure_reason || '' }}
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Previous Version
        id: collect-previous-version
        uses: folio-org/kitfox-github/.github/actions/collect-app-version@master
        with:
          app_name: ${{ inputs.repo }}
          branch: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Module Versions
        id: update-module-versions
        env:
          DOCKER_REGISTRY: "https://hub.docker.com/v2/repositories"
          NPM_REGISTRY: "https://repository.folio.org/repository"
          FOLIO_REGISTRY: "https://folio-registry.dev.folio.org/_/proxy/modules?latest=10&order=desc&orderBy=id&filter="
        run: |
          set -eo pipefail
          echo "::notice::Check for newer module versions"
          
          if [[ ! -f $STATE_FILE ]]; then
            echo "::error::$STATE_FILE not found"
            echo "failure_reason=$STATE_FILE not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          updated_modules=""
          updates=0
          
          while IFS=$'\t' read -r type module_name current_version; do
            echo "::group::Checking $type module: $module_name (current: $current_version)"
          
            pre_release="&$([[ "$type" == "backend" ]] && echo "preRelease=" || echo "npmSnapshot=")${{ inputs.pre_release }}"
          
            echo "::notice::Fetching latest version list from $FOLIO_REGISTRY$module_name$pre_release"
            registry_resp="$(curl -fsSL "$FOLIO_REGISTRY$module_name$pre_release" || true)"          
          
            if [[ -z "$registry_resp" ]]; then
              echo "::error::Failed to fetch latest module versions from registry for $module_name"
              echo "failure_reason=Failed to fetch latest module versions from registry for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          
            latest_version=""
            mapfile -t versions < <(jq -r '.[].id' <<<"$registry_resp" | sed "s/^${module_name}-//")

            for version in "${versions[@]}"; do
              module_name_esc=$module_name
              
              if [[ "$type" == "ui" ]]; then
                module_name_esc="${module_name#folio_}" # Remove folio_ prefix
                module_name_esc="${module_name_esc//_/-}" # Replace _ with -
                module_name_esc="@folio/$module_name_esc" # Add @folio scope for UI modules    
              fi
          
              is_snapshot=$([[ "$version" == *SNAPSHOT* || $(awk -F'.' '{print length($NF)}' <<< "$version") -gt 4 ]] && echo true || echo false)
              repository=$([[ "$is_snapshot" == "true" ]] && echo "folioci" || echo "folioorg")
              repository=$([[ "$type" == "ui" ]] && echo "npm-$repository" || echo "$repository")
          
              artifact_path=$([[ "$type" == "backend" ]] && \
                        echo "$DOCKER_REGISTRY/$repository/$module_name_esc/tags/$version" || \
                        echo "$NPM_REGISTRY/$repository/$module_name_esc")
          
              echo "::notice::Check artifact existence in $artifact_path"
              resp="$(curl -fsSL "$artifact_path" || true)"
              if [[ -z "$resp" ]]; then
                echo "::warning::Failed to check artifact existence for $module_name version $version"
                continue
              fi
              
              if [[ "$type" == "ui" ]]; then                
                ui_version=$(jq -r --arg ver "$version" '
                    if .versions[$ver] then $ver else "" end
                  ' <<<"$resp")
          
                if [[ -z "$ui_version" ]]; then
                  echo "::warning::Failed to find ui npm package for $module_name version $version"
                  continue
                fi
              fi
          
              latest_version="$version"
              break
            done
          
            if [[ -z "$latest_version" ]]; then
              echo "::error::Failed to fetch module artifacts from repository for $module_name"
              echo "failure_reason=Failed to fetch module artifacts from repository for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            
            if [[ -n "$latest_version" && "$latest_version" != "$current_version" ]]; then
              echo "A new $type module version discovered: $module_name $current_version -> $latest_version"
          
              jq --arg name "$module_name" --arg version "$latest_version" '
                  (.modules)   |= ((. // []) | map(if .name == $name then .version = $version else . end)) |
                  (.uiModules) |= ((. // []) | map(if .name == $name then .version = $version else . end))
                ' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

              
              updated_modules+="$module_name $current_version -> $latest_version"$'\n'
              ((++updates))
            else
              echo "â†’ Up to date (no newer version found)"
            fi
            echo "::endgroup::"
          done <<< "$(jq -r '
            (.modules[]?    | ["backend",   .name, .version]),
            (.uiModules[]?  | ["ui", .name, .version])
            | @tsv
          ' $STATE_FILE)"

          
          echo "::notice::Found $updates module updates available"
          echo "updated=$([[ $updates -gt 0 ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "updates=$updates" >> "$GITHUB_OUTPUT"
          {
            echo 'updated_modules<<EOF'
            printf '%s' "$updated_modules"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Calculate New Version
        id: calculate-new-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          MAJOR: ${{ steps.collect-previous-version.outputs.major }}
          MINOR: ${{ steps.collect-previous-version.outputs.minor }}
          PATCH: ${{ steps.collect-previous-version.outputs.patch }}
          IS_SNAPSHOT: ${{ steps.collect-previous-version.outputs.is_snapshot }}
          RUN_NUMBER: ${{ inputs.workflow_run_number }}
          DESCRIPTOR_BUILD_OFFSET: ${{ fromJSON(inputs.descriptor_build_offset || '0') }}
          IS_RELEASE_FLOW: ${{ inputs.is_release_flow }}
        run: |
          set -eo pipefail
          echo "::notice::Calculate new version"

          if [[ "$IS_RELEASE_FLOW" == "true" ]]; then
            # For release flow, increment patch version
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          elif [[ "$IS_SNAPSHOT" == "true" ]]; then
            # For snapshot flow, use build number
            BUILD_NUMBER=$((DESCRIPTOR_BUILD_OFFSET + RUN_NUMBER))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-SNAPSHOT.${BUILD_NUMBER}"
          else
            # Default: increment patch
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          echo "::notice::Calculated new version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: Update Application Version
        id: update-application-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          NEW_VERSION: ${{ steps.calculate-new-version.outputs.new_version }}
        run: |
          set -eo pipefail
          
          echo "::notice::Extracting current application version"
          PREVIOUS_VERSION=$(jq -r '.version' $STATE_FILE)
          echo "::notice::Current application version is $PREVIOUS_VERSION"
          
          echo "::notice::Update application version from $PREVIOUS_VERSION to $NEW_VERSION"          
          jq --arg version "$NEW_VERSION" '.version = $version' $STATE_FILE > temp.json && mv temp.json $STATE_FILE          
          echo "::notice::Updated application version to $NEW_VERSION"
          
          echo "updated=true" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "previous_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"

      - name: Generate Application Descriptor
        id: generate-application-descriptor
        if: steps.update-application-version.outputs.updated == 'true'
        env:
          SUPRESS_LOGS: "-Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn"
          COMMAND: "org.folio:folio-application-generator:generateFromJson"
        run: |
          set -eo pipefail
                    
          if [[ ! -f "pom.xml" ]]; then
            echo "::error::pom.xml not found"
            echo "failure_reason=pom.xml not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          echo "::notice:: Full Maven command: mvn $SUPRESS_LOGS clean $COMMAND -U -e -DtemplatePath=$STATE_FILE"
          echo "::group::Generate application artifact"
          mvn "$SUPRESS_LOGS" clean "$COMMAND" -U -e "-DtemplatePath=$STATE_FILE"
          echo "::endgroup::"
          
          echo "::group::Debug - Check target directory contents"
          ls -la target/ || echo "Target directory does not exist"
          echo "::endgroup::"
          
          APP_DESCRIPTOR_FILE=$(compgen -G "target/${APP_NAME}*.json" | head -n 1)
          if [[ -z "$APP_DESCRIPTOR_FILE" ]]; then
            echo "::error::Generated application descriptor not found"
            echo "failure_reason=Generated application descriptor not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          APP_DESCRIPTOR_FILENAME=$(basename "$APP_DESCRIPTOR_FILE")
          echo "app_descriptor_file=$APP_DESCRIPTOR_FILENAME" >> "$GITHUB_OUTPUT"
          echo "app_descriptor_file_name=${APP_DESCRIPTOR_FILENAME%.json}" >> "$GITHUB_OUTPUT"
          
          echo "::notice::Application artifact generated successfully: $APP_DESCRIPTOR_FILENAME"

      - name: Upload State File
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-state-file"
          path: ${{ env.STATE_FILE }}
          retention-days: 1

      - name: Upload Descriptor
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-descriptor"
          path: "target/${{ env.APP_NAME }}*.json"
          retention-days: 1
