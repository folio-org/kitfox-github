name: Update Application (Reusable)

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name'
        required: true
        type: string
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      branch:
        description: 'Branch to update'
        required: false
        type: string
        default: 'snapshot'
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      descriptor_build_offset:
        description: 'Offset to apply to application artifact version'
        required: false
        type: string
        default: '100100000000000'
      mode:
        description: 'Update mode (snapshot | release)'
        required: false
        type: string
        default: 'snapshot'
      target_version:
        description: 'Target version to set (overrides calculated version)'
        required: false
        type: string
        default: ''
      placeholder_modules:
        description: 'Use placeholder <CHANGE_ME> for module versions (for release preparation)'
        required: false
        type: boolean
        default: false
    outputs:
      updated:
        description: 'Whether application was updated'
        value: ${{ jobs.update-application.outputs.updated }}
      previous_version:
        description: 'Previous application version'
        value: ${{ jobs.update-application.outputs.previous_version }}
      new_version:
        description: 'New application version if updated'
        value: ${{ jobs.update-application.outputs.new_version }}
      updates_cnt:
        description: 'Number of updated modules'
        value: ${{ jobs.update-application.outputs.updates_cnt }}
      updated_modules:
        description: 'List of updated modules'
        value: ${{ jobs.update-application.outputs.updated_modules }}
      app_descriptor_file:
        description: 'Generated application descriptor file path'
        value: ${{ jobs.update-application.outputs.app_descriptor_file }}
      app_descriptor_file_name:
        description: 'Name of generated application descriptor file'
        value: ${{ jobs.update-application.outputs.app_descriptor_file_name }}
      failure_reason:
        description: 'Reason for failure'
        value: ${{ jobs.update-application.outputs.failure_reason }}

permissions:
  contents: read

env:
  STATE_FILE: "application-descriptor.json"
  APP_NAME: ${{ inputs.app_name }}
  FOLIO_REGISTRY: "https://folio-registry.dev.folio.org/_/proxy/modules?latest=10&order=desc&orderBy=id&filter="

jobs:
  update-application:
    name: Update Application
    runs-on: ubuntu-latest
    outputs:
      updated_modules: ${{ steps.update-module-versions.outputs.updated_modules || steps.set-placeholder-modules.outputs.updated_modules }}
      updated: ${{ steps.update-module-versions.outputs.updated || steps.set-placeholder-modules.outputs.updated }}
      updates_cnt: ${{ steps.update-module-versions.outputs.updates || steps.set-placeholder-modules.outputs.updates }}
      previous_version: ${{ steps.update-application-version.outputs.previous_version }}
      new_version: ${{ steps.update-application-version.outputs.new_version }}
      app_descriptor_file: ${{ steps.generate-application-descriptor.outputs.descriptor_file }}
      app_descriptor_file_name: ${{ steps.generate-application-descriptor.outputs.descriptor_file_name }}
      failure_reason: ${{ steps.update-module-versions.outputs.failure_reason || 
        steps.set-placeholder-modules.outputs.failure_reason ||
        steps.generate-application-descriptor.outputs.failure_reason || '' }}
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Previous Version
        id: collect-previous-version
        uses: folio-org/kitfox-github/.github/actions/collect-app-version@master
        with:
          app_name: ${{ inputs.repo }}
          branch: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Placeholder Module Versions
        id: set-placeholder-modules
        if: inputs.placeholder_modules == true
        env:
          TARGET_VERSION: ${{ inputs.target_version }}
        run: |
          set -eo pipefail
          
          echo "::notice::Setting placeholder module versions"
          
          jq --arg newVer "${TARGET_VERSION:-<CHANGE_ME>}" '
            (if $newVer != "<CHANGE_ME>" then .version = $newVer else . end)
            | .modules     
            |= map(.version = "<CHANGE_ME>")
            | .uiModules    
            |= map(.version = "<CHANGE_ME>")
          ' $STATE_FILE > temp.json && mv temp.json $STATE_FILE
          
          echo "::notice::Set placeholder versions for all modules"
          echo "updated=true" >> "$GITHUB_OUTPUT"
          echo "updates=0" >> "$GITHUB_OUTPUT"
          echo "updated_modules=All modules set to placeholder <CHANGE_ME>" >> "$GITHUB_OUTPUT"

      - name: Update Module Versions
        id: update-module-versions
        if: inputs.placeholder_modules != true
        env:
          DOCKER_REGISTRY: "https://hub.docker.com/v2/repositories"
          NPM_REGISTRY: "https://repository.folio.org/repository"
          FOLIO_REGISTRY: "https://folio-registry.dev.folio.org/_/proxy/modules?latest=20&order=desc&orderBy=id&filter="
          MODE: ${{ inputs.mode }}
          BACKEND_PRE_RELEASE: ${{ inputs.mode == 'snapshot' && 'preRelease=only' || 'preRelease=false' }}
          UI_PRE_RELEASE: ${{ inputs.mode == 'snapshot' && 'npmSnapshot=only' || 'npmSnapshot=false' }}
        run: |
          set -eo pipefail
          echo "::notice::Check for newer module versions"
          
          if [[ ! -f $STATE_FILE ]]; then
            echo "::error::$STATE_FILE not found"
            echo "failure_reason=$STATE_FILE not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          updated_modules=""
          updates=0
          
          while IFS=$'\t' read -r type module_name current_version; do
            echo "::group::Checking $type module: $module_name (current: $current_version)"
          
            if ! [[ "$current_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z\.-]+)?$ ]]; then
              echo "::warning::The current version '$current_version' is not semver; skipping $module_name"
              echo "::endgroup::"
              continue
            fi
          
            if [[ "$MODE" == "release" ]] && ! [[ "$current_version" =~ ^[0-9]+\.[0-9]+\.[0-9]{1,3}$ ]]; then
              echo "::warning::The current version '$current_version' is not a release version; skipping $module_name"
              echo "::endgroup::"
              continue
            fi

            pre_release="&$([[ "$type" == "backend" ]] && echo "$BACKEND_PRE_RELEASE" || echo "$UI_PRE_RELEASE")"
          
            echo "::notice::Fetching latest version list from $FOLIO_REGISTRY$module_name$pre_release"
            registry_resp="$(curl -fsSL "$FOLIO_REGISTRY$module_name$pre_release" || true)"          
          
            if [[ -z "$registry_resp" ]]; then
              echo "::error::Failed to fetch latest module versions from registry for $module_name"
              echo "failure_reason=Failed to fetch latest module versions from registry for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          
            latest_version=""
            mapfile -t versions < <(jq -r '.[].id' <<<"$registry_resp" | sed "s/^${module_name}-//")

            for version in "${versions[@]}"; do
              module_name_esc=$module_name
          
              # e.g., skip 2.x.x when current is 1.x.x
              if [[ $RELEASE_ONLY && "${version%%.*}" != "${current_version%%.*}" ]]; then
                echo "::warning::Skipping $type module $module_name version $version"
                continue
              fi
              
              if [[ "$type" == "ui" ]]; then
                module_name_esc="${module_name#folio_}" # Remove folio_ prefix
                module_name_esc="${module_name_esc//_/-}" # Replace _ with -
                module_name_esc="@folio/$module_name_esc" # Add @folio scope for UI modules    
              fi
          
              is_snapshot=$([[ "$version" == *SNAPSHOT* || $(awk -F'.' '{print length($NF)}' <<< "$version") -gt 4 ]] && echo true || echo false)
              repository=$([[ "$is_snapshot" == "true" ]] && echo "folioci" || echo "folioorg")
              repository=$([[ "$type" == "ui" ]] && echo "npm-$repository" || echo "$repository")
          
              artifact_path=$([[ "$type" == "backend" ]] && \
                        echo "$DOCKER_REGISTRY/$repository/$module_name_esc/tags/$version" || \
                        echo "$NPM_REGISTRY/$repository/$module_name_esc")
          
              echo "::notice::Check artifact existence in $artifact_path"
              resp="$(curl -fsSL "$artifact_path" || true)"
              if [[ -z "$resp" ]]; then
                echo "::warning::Failed to check artifact existence for $module_name version $version"
                continue
              fi
              
              if [[ "$type" == "ui" ]]; then                
                ui_version=$(jq -r --arg ver "$version" '
                    if .versions[$ver] then $ver else "" end
                  ' <<<"$resp")
          
                if [[ -z "$ui_version" ]]; then
                  echo "::warning::Failed to find ui npm package for $module_name version $version"
                  continue
                fi
              fi
          
              latest_version="$version"
              break
            done
          
            if [[ -z "$latest_version" ]]; then
              echo "::error::Failed to fetch module artifacts from repository for $module_name"
              echo "failure_reason=Failed to fetch module artifacts from repository for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            
            if [[ -n "$latest_version" && "$latest_version" != "$current_version" ]]; then
              echo "A new $type module version discovered: $module_name $current_version -> $latest_version"
          
              jq --arg name "$module_name" --arg version "$latest_version" '
                  (.modules)   |= ((. // []) | map(if .name == $name then .version = $version else . end)) |
                  (.uiModules) |= ((. // []) | map(if .name == $name then .version = $version else . end))
                ' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

              
              updated_modules+="$module_name $current_version -> $latest_version"$'\n'
              ((++updates))
            else
              echo "→ Up to date (no newer version found)"
            fi
            echo "::endgroup::"
          done <<< "$(jq -r '
            (.modules[]?    | ["backend",   .name, .version]),
            (.uiModules[]?  | ["ui", .name, .version])
            | @tsv
          ' $STATE_FILE)"

          
          echo "::notice::Found $updates module updates available"
          echo "updated=$([[ $updates -gt 0 ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "updates=$updates" >> "$GITHUB_OUTPUT"
          {
            echo 'updated_modules<<EOF'
            printf '%s' "$updated_modules"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Calculate New Version
        id: calculate-new-version
        if: (steps.update-module-versions.outputs.updated == 'true' || steps.set-placeholder-modules.outputs.updated == 'true') && inputs.target_version == ''
        env:
          MAJOR: ${{ steps.collect-previous-version.outputs.major }}
          MINOR: ${{ steps.collect-previous-version.outputs.minor }}
          PATCH: ${{ steps.collect-previous-version.outputs.patch }}
          IS_SNAPSHOT: ${{ steps.collect-previous-version.outputs.is_snapshot }}
          RUN_NUMBER: ${{ inputs.workflow_run_number }}
          DESCRIPTOR_BUILD_OFFSET: ${{ fromJSON(inputs.descriptor_build_offset || '0') }}
        run: |
          set -eo pipefail
          echo "::notice::Calculate new version"

          if [[ "$IS_SNAPSHOT" == "true" ]]; then
            BUILD_NUMBER=$((DESCRIPTOR_BUILD_OFFSET + RUN_NUMBER))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-SNAPSHOT.${BUILD_NUMBER}"
          else
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          echo "::notice::Calculated new version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: Update POM Version
        id: update-pom-version
        if: inputs.target_version != '' || (inputs.mode == 'release' && (steps.update-module-versions.outputs.updated == 'true' || steps.set-placeholder-modules.outputs.updated == 'true'))
        env:
          NEW_VERSION: ${{ inputs.target_version || steps.calculate-new-version.outputs.new_version }}
        run: |
          set -eo pipefail

          if [[ -n "$NEW_VERSION" && -f "pom.xml" ]]; then
            CURRENT_POM_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            
            if [[ "$CURRENT_POM_VERSION" != "$NEW_VERSION" ]]; then
              echo "::notice::Updating pom.xml for ${{ inputs.mode == 'release' && 'release' || 'explicit version' }}"
              echo "::group::Updating pom.xml version from $CURRENT_POM_VERSION to $NEW_VERSION"
              mvn versions:set \
                  -DnewVersion="$NEW_VERSION" \
                  -DgenerateBackupPoms=false
              echo "::endgroup::"
              
              echo "::notice::Successfully updated pom.xml version to $NEW_VERSION"
            else
              echo "::notice::POM version already matches target version: $NEW_VERSION"
            fi
          else
            echo "::notice::Skipping POM update (snapshot mode with calculated version)"
          fi

      - name: Update Application Version
        id: update-application-version
        if: steps.update-module-versions.outputs.updated == 'true' || steps.set-placeholder-modules.outputs.updated == 'true'
        env:
          NEW_VERSION: ${{ inputs.target_version || steps.calculate-new-version.outputs.new_version }}
        run: |
          set -eo pipefail
          
          echo "::notice::Extracting current application version"
          PREVIOUS_VERSION=$(jq -r '.version' $STATE_FILE)
          echo "::notice::Current application version is $PREVIOUS_VERSION"
          
          echo "::notice::Update application version from $PREVIOUS_VERSION to $NEW_VERSION"          
          jq --arg version "$NEW_VERSION" '.version = $version' $STATE_FILE > temp.json && mv temp.json $STATE_FILE          
          echo "::notice::Updated application version to $NEW_VERSION"
          
          echo "updated=true" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "previous_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"

      - name: Generate Application Descriptor
        id: generate-application-descriptor
        if: inputs.placeholder_modules != true && steps.update-application-version.outputs.updated == 'true'
        uses: ./.github/actions/generate-application-descriptor
        with:
          app_name: ${{ env.APP_NAME }}
          state_file: ${{ env.STATE_FILE }}
          upload_artifact: true

      - name: Upload Application Update Files
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-update-files"
          path: |
            ${{ env.STATE_FILE }}
            pom.xml
          retention-days: 1
