name: Compare Application Versions

on:
  workflow_call:
    inputs:
      repo:
        description: 'Repository (org/repo format)'
        required: true
        type: string
      base_branch:
        description: 'Base branch to compare against'
        required: true
        type: string
      head_branch:
        description: 'Head branch to compare (optional if using artifact)'
        required: false
        type: string
        default: ''
      artifact_name:
        description: 'Artifact name containing application descriptor (optional if using branch)'
        required: false
        type: string
        default: ''
      state_file:
        description: 'Name of the state file (application descriptor)'
        required: false
        type: string
        default: 'application-descriptor.json'
    outputs:
      updated_modules:
        description: 'List of updated modules'
        value: ${{ jobs.compare.outputs.updated_modules }}
      updates_cnt:
        description: 'Number of module updates'
        value: ${{ jobs.compare.outputs.updates_cnt }}
      new_version:
        description: 'New version of the application'
        value: ${{ jobs.compare.outputs.new_version }}
      has_changes:
        description: 'Whether there are changes between versions'
        value: ${{ jobs.compare.outputs.has_changes }}

jobs:
  compare:
    name: Compare Application Versions
    runs-on: ubuntu-latest
    outputs:
      updated_modules: ${{ steps.compare-versions.outputs.updated_modules }}
      updates_cnt: ${{ steps.compare-versions.outputs.updates_cnt }}
      new_version: ${{ steps.compare-versions.outputs.new_version }}
      has_changes: ${{ steps.compare-versions.outputs.has_changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.base_branch }}
          fetch-depth: 0

      - name: Get base version info
        id: base-version
        env:
          STATE_FILE: ${{ inputs.state_file }}
        run: |
          if [ -f "$STATE_FILE" ]; then
            base_version=$(jq -r '.version // "unknown"' "$STATE_FILE")
            echo "base_version=$base_version" >> "$GITHUB_OUTPUT"
            
            # Save base state for comparison
            cp "$STATE_FILE" base_state.json
          else
            echo "::error::State file not found in base branch"
            exit 1
          fi

      - name: Download artifact if specified
        if: inputs.artifact_name != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: artifact

      - name: Get head state from artifact
        if: inputs.artifact_name != ''
        env:
          STATE_FILE: ${{ inputs.state_file }}
        run: |
          if [ -f "artifact/$STATE_FILE" ]; then
            cp "artifact/$STATE_FILE" head_state.json
          else
            echo "::error::State file not found in artifact"
            exit 1
          fi

      - name: Get head state from branch
        if: inputs.head_branch != ''
        env:
          HEAD_BRANCH: ${{ inputs.head_branch }}
          STATE_FILE: ${{ inputs.state_file }}
        run: |
          git fetch origin "$HEAD_BRANCH"
          git checkout "origin/$HEAD_BRANCH" -- "$STATE_FILE"
          
          if [ -f "$STATE_FILE" ]; then
            cp "$STATE_FILE" head_state.json
          else
            echo "::error::State file not found in head branch"
            exit 1
          fi

      - name: Compare versions and generate module list
        id: compare-versions
        run: |
          echo "::notice::Comparing application versions"
          
          # Get versions
          base_version=$(jq -r '.version // "unknown"' base_state.json)
          head_version=$(jq -r '.version // "unknown"' head_state.json)
          
          echo "Base version: $base_version"
          echo "Head version: $head_version"
          
          # Compare dependencies
          updated_modules=""
          updates_cnt=0
          
          # Get all unique module names from both states
          all_modules=$(jq -r '.dependencies | keys[]' base_state.json head_state.json 2>/dev/null | sort -u)
          
          for module in $all_modules; do
            base_ver=$(jq -r ".dependencies[\"$module\"] // \"not present\"" base_state.json)
            head_ver=$(jq -r ".dependencies[\"$module\"] // \"not present\"" head_state.json)
            
            if [ "$base_ver" != "$head_ver" ]; then
              if [ "$base_ver" = "not present" ]; then
                module_update="+ $module: $head_ver (new)"
              elif [ "$head_ver" = "not present" ]; then
                module_update="- $module: $base_ver (removed)"
              else
                module_update="$module: $base_ver â†’ $head_ver"
              fi
              
              if [ -z "$updated_modules" ]; then
                updated_modules="$module_update"
              else
                updated_modules="$updated_modules"$'\n'"$module_update"
              fi
              updates_cnt=$((updates_cnt + 1))
            fi
          done
          
          # Check if there are changes
          if [ "$updates_cnt" -gt 0 ] || [ "$base_version" != "$head_version" ]; then
            has_changes=true
          else
            has_changes=false
          fi
          
          # Output results
          echo "updated_modules<<EOF" >> "$GITHUB_OUTPUT"
          echo "$updated_modules" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "updates_cnt=$updates_cnt" >> "$GITHUB_OUTPUT"
          echo "new_version=$head_version" >> "$GITHUB_OUTPUT"
          echo "has_changes=$has_changes" >> "$GITHUB_OUTPUT"
          
          # Display summary
          echo "::notice::Found $updates_cnt module updates"
          if [ -n "$updated_modules" ]; then
            echo "::notice::Updated modules:"
            echo "$updated_modules"
          fi