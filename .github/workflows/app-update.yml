name: Application Update

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name'
        required: true
        type: string
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      branch:
        description: 'Branch to update'
        required: false
        type: string
        default: 'snapshot'
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      descriptor_build_offset:
        description: 'Offset to apply to application artifact version'
        required: false
        type: string
        default: '100100000000000'
      rely_on_FAR:
        description: 'Whether to rely on FAR for application descriptor dependencies'
        required: false
        type: boolean
        default: false
      pre_release:
        description: 'Pre-release modules (only | true | false)'
        required: false
        type: string
        default: 'only'
      dry_run:
        description: 'Perform dry run without making changes'
        required: false
        type: boolean
        default: false
    outputs:
      app_name:
        description: 'Application name'
        value: ${{ inputs.app_name }}
      updated:
        description: 'Whether application was updated'
        value: ${{ jobs.update-descriptor.outputs.updated }}
      previous_version:
        description: 'Previous application version'
        value: ${{ jobs.update-descriptor.outputs.previous_version }}
      new_version:
        description: 'New application version if updated'
        value: ${{ jobs.update-descriptor.outputs.new_version }}
      updated_cnt:
        description: 'Number of updated modules'
        value: ${{ jobs.update-descriptor.outputs.updates_cnt }}
      updated_modules:
        description: 'List of updated modules'
        value: ${{ jobs.update-descriptor.outputs.updated_modules }}
      failure_reason:
        description: 'Reason for failure'
        value: ${{ jobs.update-descriptor.outputs.failure_reason || 
          jobs.verify-publish-descriptor.outputs.failure_reason || 
          jobs.commit-statefile.outputs.failure_reason || 'unknown' }}
      commit_sha:
        description: 'Commit SHA'
        value: ${{ jobs.commit-statefile.outputs.commit_sha }}
      app_descriptor_url:
        description: 'URL of generated application descriptor'
        value: ${{ format('{0}/{1}?full=true', 'https://far.ci.folio.org/applications', jobs.update-descriptor.outputs.app_descriptor_file_name) }}
      app_descriptor_file_name:
        description: 'Name of generated application descriptor file'
        value: ${{ jobs.update-descriptor.outputs.app_descriptor_file_name }}
    secrets:
      GH_APP_TOKEN:
        description: 'GitHub token for repository access'
        required: false

permissions:
  contents: write

env:
  STATE_FILE: "application-descriptor.json"
  PLATFORM_DESCRIPTOR: "platform-descriptor"
  APP_NAME: ${{ inputs.app_name }}
  FAR_API_URL: "https://far.ci.folio.org/applications"

jobs:
  update-descriptor:
    name: Update Application Descriptor
    runs-on: ubuntu-latest
    outputs:
      updated_modules: ${{ steps.update-module-versions.outputs.updated_modules }}
      updated: ${{ steps.update-module-versions.outputs.updated }}
      updates_cnt: ${{ steps.update-module-versions.outputs.updates }}
      previous_version: ${{ steps.update-application-version.outputs.previous_version }}
      new_version: ${{ steps.update-application-version.outputs.new_version }}
      app_descriptor_file: ${{ steps.generate-application-descriptor.outputs.app_descriptor_file }}
      app_descriptor_file_name: ${{ steps.generate-application-descriptor.outputs.app_descriptor_file_name }}
      failure_reason: ${{ steps.update-module-versions.outputs.failure_reason || 
        steps.generate-application-descriptor.outputs.failure_reason || '' }}
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Previous Version
        id: collect-previous-version
        uses: folio-org/kitfox-github/.github/actions/collect-app-version@master
        with:
          app_name: ${{ inputs.repo }}
          branch: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Module Versions (OUTDATED)
        id: update-module-versions-old
        env:
          DOCKER_REGISTRY: "https://hub.docker.com/v2/repositories"
          NPM_REGISTRY: "https://repository.folio.org/repository/npm-folioci"
        run: |
          set -eo pipefail
          echo "::notice::Check for newer module versions"
          
          if [[ ! -f $STATE_FILE ]]; then
            echo "::error::$STATE_FILE not found"
            echo "failure_reason=$STATE_FILE not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          updated_modules=""
          updates=0
          
          while IFS=$'\t' read -r type module_name current_version; do
            echo "::group::Checking $type module: $module_name (current: $current_version)" 
            
            module_name_esc=$module_name
            
            if [[ "$type" != "backend" ]]; then
              module_name_esc="${module_name#folio_}" # Remove folio_ prefix
              module_name_esc="${module_name_esc//_/-}" # Replace _ with -
              [ "$type" = "ui" ] && module_name_esc="@folio/$module_name_esc" # Add @folio scope for UI modules
            
              module_name_esc="${module_name_esc//@/%40}" # Replace @ with %40
              module_name_esc="${module_name_esc//\//%2F}" # Replace / with %2F        
            fi
          
            if [[ "$type" == "backend" ]]; then
              image_path="${DOCKER_REGISTRY%/}/folioci/$module_name_esc/tags?ordering=last_updated"
              jq_filter='.results[]? | select(.name | test("-SNAPSHOT(\\.|-|$)")) | .name'
            else
              image_path="${NPM_REGISTRY%/}/$module_name_esc"
              jq_filter='."dist-tags".latest // empty'
            fi
                   
            echo "::notice::Fetching tags from $image_path"
            resp="$(curl -fsSL "$image_path" || true)"
            if [[ -z "$resp" ]]; then
              echo "::warning::Failed to fetch tags for $module_name"
              echo "::endgroup::"
              continue
            fi

            latest_version="$(echo "$resp" | jq -r "$jq_filter" | head -n1)"
            
            if [[ -n "$latest_version" && "$latest_version" != "$current_version" ]]; then
              echo "A new $type module version discovered: $module_name $current_version -> $latest_version"
          
              jq --arg name "$module_name" --arg version "$latest_version" '
                  (.modules)   |= ((. // []) | map(if .name == $name then .version = $version else . end)) |
                  (.uiModules) |= ((. // []) | map(if .name == $name then .version = $version else . end))
                ' "$STATE_FILE" > "$STATE_FILE.tmp" #&& mv "$STATE_FILE.tmp" "$STATE_FILE"
              
              updated_modules+="$module_name $current_version -> $latest_version"$'\n'
              ((++updates))
            else
              echo "→ Up to date (no newer version found)"
            fi
            echo "::endgroup::"
          done <<< "$(jq -r '
            (.modules[]?    | ["backend",   .name, .version]),
            (.uiModules[]?  | ["ui", .name, .version])
            | @tsv
          ' $STATE_FILE)"

          
          echo "::notice::Found $updates module updates available"

      - name: Update Module Versions
        id: update-module-versions
        env:
          DOCKER_REGISTRY: "https://hub.docker.com/v2/repositories"
          NPM_REGISTRY: "https://repository.folio.org/repository"
          FOLIO_REGISTRY: "https://folio-registry.dev.folio.org/_/proxy/modules?latest=10&order=desc&orderBy=id&filter="
        run: |
          set -eo pipefail
          echo "::notice::Check for newer module versions"
          
          if [[ ! -f $STATE_FILE ]]; then
            echo "::error::$STATE_FILE not found"
            echo "failure_reason=$STATE_FILE not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          updated_modules=""
          updates=0
          
          while IFS=$'\t' read -r type module_name current_version; do
            echo "::group::Checking $type module: $module_name (current: $current_version)"
          
            pre_release="&$([[ "$type" == "backend" ]] && echo "preRelease=" || echo "npmSnapshot=")${{ inputs.pre_release }}"
          
            echo "::notice::Fetching latest version list from $FOLIO_REGISTRY$module_name$pre_release"
            registry_resp="$(curl -fsSL "$FOLIO_REGISTRY$module_name$pre_release" || true)"          
          
            if [[ -z "$registry_resp" ]]; then
              echo "::error::Failed to fetch latest module versions from registry for $module_name"
              echo "failure_reason=Failed to fetch latest module versions from registry for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          
            latest_version=""
            mapfile -t versions < <(jq -r '.[].id' <<<"$registry_resp" | sed "s/^${module_name}-//")

            for version in "${versions[@]}"; do
              module_name_esc=$module_name
              
              if [[ "$type" == "ui" ]]; then
                module_name_esc="${module_name#folio_}" # Remove folio_ prefix
                module_name_esc="${module_name_esc//_/-}" # Replace _ with -
                module_name_esc="@folio/$module_name_esc" # Add @folio scope for UI modules    
              fi
          
              is_snapshot=$([[ "$version" == *SNAPSHOT* || $(awk -F'.' '{print length($NF)}' <<< "$version") -gt 4 ]] && echo true || echo false)
              repository=$([[ "$is_snapshot" == "true" ]] && echo "folioci" || echo "folioorg")
              repository=$([[ "$type" == "ui" ]] && echo "npm-$repository" || echo "$repository")
          
              artifact_path=$([[ "$type" == "backend" ]] && \
                        echo "$DOCKER_REGISTRY/$repository/$module_name_esc/tags/$version" || \
                        echo "$NPM_REGISTRY/$repository/$module_name_esc")
          
              echo "::notice::Check artifact existence in $artifact_path"
              resp="$(curl -fsSL "$artifact_path" || true)"
              if [[ -z "$resp" ]]; then
                echo "::warning::Failed to check artifact existence for $module_name version $version"
                continue
              fi
              
              if [[ "$type" == "ui" ]]; then                
                ui_version=$(jq -r --arg ver "$version" '
                    if .versions[$ver] then $ver else "" end
                  ' <<<"$resp")
          
                if [[ -z "$ui_version" ]]; then
                  echo "::warning::Failed to find ui npm package for $module_name version $version"
                  continue
                fi
              fi
          
              latest_version="$version"
              break
            done
          
            if [[ -z "$latest_version" ]]; then
              echo "::error::Failed to fetch module artifacts from repository for $module_name"
              echo "failure_reason=Failed to fetch module artifacts from repository for $module_name" >> "$GITHUB_OUTPUT"
              exit 1
            fi
            
            if [[ -n "$latest_version" && "$latest_version" != "$current_version" ]]; then
              echo "A new $type module version discovered: $module_name $current_version -> $latest_version"
          
              jq --arg name "$module_name" --arg version "$latest_version" '
                  (.modules)   |= ((. // []) | map(if .name == $name then .version = $version else . end)) |
                  (.uiModules) |= ((. // []) | map(if .name == $name then .version = $version else . end))
                ' "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

              
              updated_modules+="$module_name $current_version -> $latest_version"$'\n'
              ((++updates))
            else
              echo "→ Up to date (no newer version found)"
            fi
            echo "::endgroup::"
          done <<< "$(jq -r '
            (.modules[]?    | ["backend",   .name, .version]),
            (.uiModules[]?  | ["ui", .name, .version])
            | @tsv
          ' $STATE_FILE)"

          
          echo "::notice::Found $updates module updates available"
          echo "updated=$([[ $updates -gt 0 ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "updates=$updates" >> "$GITHUB_OUTPUT"
          {
            echo 'updated_modules<<EOF'
            printf '%s' "$updated_modules"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Calculate New Version
        id: calculate-new-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          MAJOR: ${{ steps.collect-previous-version.outputs.major }}
          MINOR: ${{ steps.collect-previous-version.outputs.minor }}
          PATCH: ${{ steps.collect-previous-version.outputs.patch }}
          IS_SNAPSHOT: ${{ steps.collect-previous-version.outputs.is_snapshot }}
          RUN_NUMBER: ${{ inputs.workflow_run_number }}
          DESCRIPTOR_BUILD_OFFSET: ${{ fromJSON(inputs.descriptor_build_offset || '0') }}
        run: |
          set -eo pipefail
          echo "::notice::Calculate new version"

          if [[ "$IS_SNAPSHOT" == "true" ]]; then
            BUILD_NUMBER=$((DESCRIPTOR_BUILD_OFFSET + RUN_NUMBER))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-SNAPSHOT.${BUILD_NUMBER}"
          else
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          echo "::notice::Calculated new version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: Update Application Version
        id: update-application-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          NEW_VERSION: ${{ steps.calculate-new-version.outputs.new_version }}
        run: |
          set -eo pipefail
          
          echo "::notice::Extracting current application version"
          PREVIOUS_VERSION=$(jq -r '.version' $STATE_FILE)
          echo "::notice::Current application version is $PREVIOUS_VERSION"
          
          echo "::notice::Update application version from $PREVIOUS_VERSION to $NEW_VERSION"          
          jq --arg version "$NEW_VERSION" '.version = $version' $STATE_FILE > temp.json && mv temp.json $STATE_FILE          
          echo "::notice::Updated application version to $NEW_VERSION"
          
          echo "updated=true" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "previous_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"

      - name: Generate Application Descriptor
        id: generate-application-descriptor
        if: steps.update-application-version.outputs.updated == 'true'
        env:
          SUPRESS_LOGS: "-Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn"
          COMMAND: "org.folio:folio-application-generator:generateFromJson"
        run: |
          set -eo pipefail
                    
          if [[ ! -f "pom.xml" ]]; then
            echo "::error::pom.xml not found"
            echo "failure_reason=pom.xml not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          echo "::notice:: Full Maven command: mvn $SUPRESS_LOGS clean $COMMAND -U -e -DtemplatePath=$STATE_FILE"
          echo "::group::Generate application artifact"
          mvn "$SUPRESS_LOGS" clean "$COMMAND" -U -e "-DtemplatePath=$STATE_FILE"
          echo "::endgroup::"
          
          echo "::group::Debug - Check target directory contents"
          ls -la target/ || echo "Target directory does not exist"
          echo "::endgroup::"
          
          APP_DESCRIPTOR_FILE=$(compgen -G "target/${APP_NAME}*.json" | head -n 1)
          if [[ -z "$APP_DESCRIPTOR_FILE" ]]; then
            echo "::error::Generated application descriptor not found"
            echo "failure_reason=Generated application descriptor not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          APP_DESCRIPTOR_FILENAME=$(basename "$APP_DESCRIPTOR_FILE")
          echo "app_descriptor_file=$APP_DESCRIPTOR_FILENAME" >> "$GITHUB_OUTPUT"
          echo "app_descriptor_file_name=${APP_DESCRIPTOR_FILENAME%.json}" >> "$GITHUB_OUTPUT"
          
          echo "::notice::Application artifact generated successfully: $APP_DESCRIPTOR_FILENAME"

      - name: Upload State File
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-state-file"
          path: ${{ env.STATE_FILE }}
          retention-days: 1

      - name: Upload Descriptor
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-descriptor"
          path: "target/${{ env.APP_NAME }}*.json"
          retention-days: 1

  verify-publish-descriptor:
    name: Verify and Publish Updated Descriptor
    runs-on: ubuntu-latest
    needs: update-descriptor
    if: needs.update-descriptor.outputs.updated == 'true'
    outputs:
        failure_reason: ${{ steps.fetch-app-descriptors.outputs.failure_reason ||
          steps.validate-interfaces.outputs.failure_reason ||
          steps.validate-dependencies.outputs.failure_reason ||
          steps.upload-to-registry.outputs.failure_reason || '' }}
    steps:
      - name: Download Descriptor Artifact
        uses: actions/download-artifact@v4
        with:
          name: "${{ env.APP_NAME }}-descriptor"
          path: /tmp/app-descriptors

      - name: Download Platform Descriptor
        id: download-platform-descriptor
        if: ${{ !inputs.rely_on_FAR }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PLATFORM_DESCRIPTOR }}
          path: /tmp/${{ env.PLATFORM_DESCRIPTOR }}

      - name: Fetch Application Descriptors from FAR
        id: fetch-app-descriptors
        if: ${{ !inputs.rely_on_FAR }}
        run: |
          set -eo pipefail
          echo "::notice::Fetch application descriptors from FAR for validation"

          if [ ! -f "/tmp/$PLATFORM_DESCRIPTOR/$PLATFORM_DESCRIPTOR.json" ]; then
            echo "::error::Platform descriptor artifact not found"
            echo "failure_reason=Platform descriptor artifact not found" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          cp /tmp/$PLATFORM_DESCRIPTOR/$PLATFORM_DESCRIPTOR.json ./$PLATFORM_DESCRIPTOR.json
          echo "::notice::Platform descriptor loaded successfully"

          mkdir -p /tmp/app-descriptors
          platform_apps=$(jq -c '
            [.applications.required[]?, .applications.optional[]?] 
            | map({name: .name, version: .version})
          ' platform-descriptor.json)

          app_count=$(echo "$platform_apps" | jq 'length')
          echo "::notice::Found $app_count applications in platform descriptor"
          
          echo "$platform_apps" | jq -c '.[]' | 
          while read -r app_entry; do
            app_name=$(echo "$app_entry" | jq -r '.name')
            app_version=$(echo "$app_entry" | jq -r '.version')
          
            [[ "$app_name" == "$APP_NAME" ]] && continue
            
            echo "Fetching descriptor for $app_name version $app_version..."
            
            descriptor_url="$FAR_API_URL/$app_name-$app_version?full=true"
            if descriptor=$(curl -sf "$descriptor_url" 2>/dev/null); then
              echo "$descriptor" > "/tmp/app-descriptors/${app_name}.json"
              echo "::notice:: Fetched $app_name"
            else
              echo "::error:: Could not fetch $app_name from FAR"
              echo "failure_reason=Could not fetch $app_name from FAR" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          done
          
          echo "::notice::Application descriptors fetched for validation"

      - name: Validate Application Module Interface Integrity
        id: validate-interfaces
        env:
          APP_DESCRIPTOR_FILE: "/tmp/app-descriptors/${{ needs.update-descriptor.outputs.app_descriptor_file }}"
        run: |
          set -eo pipefail
          echo "::notice::Validate application module interface integrity"

          if [ ! -f "$APP_DESCRIPTOR_FILE" ]; then
            echo "::error::Updated descriptor not found: $APP_DESCRIPTOR_FILE"
            echo "failure_reason=Updated descriptor not found: $APP_DESCRIPTOR_FILE" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          validation_response_and_code=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            --data-binary @"$APP_DESCRIPTOR_FILE" \
            "$FAR_API_URL/validate")
          
          validation_response=$(echo "$validation_response_and_code" | sed '$d')
          http_code=$(echo "$validation_response_and_code" | tail -n1)

          if ! [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
            echo "::error::Module interface integrity validation request failed (HTTP $http_code)"
            echo "::error::$validation_response"
            echo "failure_reason=Module interface integrity validation request failed (HTTP $http_code)" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          
          echo "::notice::Module interface integrity validation passed"

      - name: Validate Application Dependencies Integrity
        id: validate-dependencies
        env:
          RELY_ON_FAR: ${{ inputs.rely_on_FAR }}
        run: |
          set -eo pipefail
          echo "::notice::Validate application dependencies integrity"

          resp_file="$(mktemp)"

          http_code="$(
            find /tmp/app-descriptors -maxdepth 1 -type f -name '*.json' -print0 \
              | xargs -0 -r cat \
              | jq -s '{applicationDescriptors: .}' \
              | curl -sS -o "$resp_file" -w "%{http_code}" -X POST \
                  -H "Content-Type: application/json" \
                  --data-binary @- \
                  "$FAR_API_URL/validate-descriptors"
          )"

          if ! [[ "$http_code" =~ ^2[0-9]{2}$ ]]; then
            echo "::error::Dependencies integrity validation request failed (HTTP $http_code)"
            
            [[ -s "$resp_file" ]] && cat "$resp_file" >&2 || echo "(empty response body)" >&2  
            
            echo "failure_reason=Dependencies integrity validation request failed (HTTP $http_code)" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "::notice::Dependencies integrity validation passed"
          [[ "$RELY_ON_FAR" == "true" ]] && cat "$resp_file" >&2 || echo "(empty response body)" >&2
          rm -f "$resp_file"

      - name: Upload to Application Registry
        id: upload-to-registry
        if: inputs.dry_run != true
        env:
          APP_DESCRIPTOR_FILE: "/tmp/app-descriptors/${{ needs.update-descriptor.outputs.app_descriptor_file }}"
        run: |
          set -eo pipefail
          echo "::notice::Upload application to registry"

          resp_file="$(mktemp)"

          http_code="$(curl -sS -o "$resp_file" -w "%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d @"$APP_DESCRIPTOR_FILE" \
            "$FAR_API_URL")"

          if ! [[ "$http_code" =~ ^2[0-9]{2}$ ]]; then
            echo "::error::Failed to upload application to registry (HTTP $http_code)"
            
            [[ -s "$resp_file" ]] && cat "$resp_file" >&2 || echo "(empty response body)" >&2
            
            echo "failure_reason=Failed to upload application to registry (HTTP $http_code)" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "::notice::Application uploaded to registry successfully"
          rm -f "$resp_file"

  commit-statefile:
    name: Commit and push sate file
    runs-on: ubuntu-latest
    needs: [update-descriptor, verify-publish-descriptor]
    outputs:
      commit_sha: ${{ steps.commit-changes.outputs.commit_sha }}
      failure_reason: ${{ steps.commit-changes.outputs.failure_reason || 
        steps.delete-uploaded-app-in-registry.outputs.failure_reason || ''}}
    steps:

      - name: Checkout Application Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GH_APP_TOKEN || github.token }}

      - name: Download StateFile Artifact
        uses: actions/download-artifact@v4
        with:
          name: "${{ env.APP_NAME }}-state-file"
          path: .

      - name: Configure Git
        env:
          PUSH_TOKEN: ${{ secrets.GH_APP_TOKEN || github.token }}
        run: |
          set -eo pipefail
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PUSH_TOKEN}@github.com/${{ inputs.repo }}.git"
          git remote -v
          echo "::notice::Git configured for automated commits"

      - name: Commit Changes
        id: commit-changes
        env:
          PREVIOUS_VERSION: ${{ needs.update-descriptor.outputs.previous_version }}
          NEW_VERSION: ${{ needs.update-descriptor.outputs.new_version }}
          UPDATED_MODULES: ${{ needs.update-descriptor.outputs.updated_modules }}
          UPDATED_CNT: ${{ needs.update-descriptor.outputs.updates_cnt }}
        run: |
          set -eo pipefail

          echo "::group::Stage changes for commit"
          git status
          echo "::endgroup::"
          
          git add $STATE_FILE 2>/dev/null || true

          if git diff --cached --quiet; then
            echo "::error::No changes to commit"
            echo "failure_reason=No changes to commit" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          git commit -F - <<EOF
          Update application state file to $NEW_VERSION".

          Previous version: $PREVIOUS_VERSION
          Total modules updated: $UPDATED_CNT
          Modules: $UPDATED_MODULES
          EOF
          
          commit_sha=$(git rev-parse HEAD)
          
          echo "::notice::Successfully committed changes #$commit_sha"
          echo "commit_sha=$commit_sha" >> "$GITHUB_OUTPUT"

      - name: Push Changes
        if: inputs.dry_run == false
        env:
          BRANCH_NAME: ${{ inputs.branch }}
        run: |
          set -eo pipefail

          echo "::notice::Pushing changes to branch '$BRANCH_NAME'"
          git push -u origin "$BRANCH_NAME"
          echo "::notice::Successfully pushed changes to '$BRANCH_NAME'"

      - name: Delete Uploaded Application in Registry
        id: delete-uploaded-app-in-registry
        if: failure() && inputs.dry_run != true
        env:
          APP_DESCRIPTOR_FILE_NAME: "${{ needs.update-descriptor.outputs.app_descriptor_file_name }}"
        run: |
          set -eo pipefail
          echo "::notice::Delete previously uploaded application APP_DESCRIPTOR_FILE_NAME in registry"

          resp_file="$(mktemp)"

          http_code="$(curl -sS -o "$resp_file" -w "%{http_code}" -X DELETE \
            -H "Content-Type: application/json" \
            "$FAR_API_URL/$APP_DESCRIPTOR_FILE_NAME")"

          if ! [[ "$http_code" =~ ^2[0-9]{2}$ ]]; then
            echo "::error::Failed to delete application in registry (HTTP $http_code)"
            
            [[ -s "$resp_file" ]] && cat "$resp_file" >&2 || echo "(empty response body)" >&2
            
            echo "failure_reason=Failed to delete application in registry (HTTP $http_code)" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "::notice::Application descriptor deleted in registry successfully"
          rm -f "$resp_file"

      - name: Workflow Summary
        run: |
          set -eo pipefail

          echo "::notice::$APP_NAME Update Summary"
          echo ""
          echo "Branch: ${{ inputs.branch }}"
          echo "Previous Version: ${{ needs.update-descriptor.outputs.previous_version }}"
          echo "New Version: ${{ needs.update-descriptor.outputs.new_version }}"
          echo "Updated Modules Count: ${{ needs.update-descriptor.outputs.updates_cnt }}"
          echo "Updated Modules: ${{ needs.update-descriptor.outputs.updated_modules }}"
          echo "Commit: ${{ steps.commit-changes.outputs.commit_sha }}"
          echo ""
          
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "::notice::This was a dry run - no actual changes were made"
            echo "::notice::Set dry_run=false to apply changes"
          fi

  upload_results:
    name: Upload Results
    runs-on: ubuntu-latest
    needs: [update-descriptor, verify-publish-descriptor, commit-statefile]
    if: always()
    steps:
      - name: Prepare Output Artifact
        id: prepare-artifact
        if: always()
        env:
          STATUS: >-
            ${{ 
                ((needs.commit-statefile.result == 'failure' || needs.verify-publish-descriptor.result == 'failure' || needs.update-descriptor.result == 'failure') && 'failed') ||
                'success'
            }}
          FAILURE_REASON: >-
            ${{ 
                needs.update-descriptor.outputs.failure_reason || 
                needs.verify-publish-descriptor.outputs.failure_reason || 
                needs.commit-statefile.outputs.failure_reason || 'unknown' 
            }}
          APP_DESCRIPTOR_URL: ${{ format('{0}/{1}?full=true', 'https://far.ci.folio.org/applications', needs.update-descriptor.outputs.app_descriptor_file_name) }}
        run: |
          set -eo pipefail

          mkdir -p /tmp/results
          
          printf '%s' "${{ needs.update-descriptor.outputs.updated_modules }}" > /tmp/updated_modules.txt
          printf '%s' "$FAILURE_REASON" > /tmp/failure_reason.txt

          jq -n \
          --arg application             "${{ inputs.app_name }}" \
          --arg status                  "$STATUS" \
          --arg previous_version        "${{ needs.update-descriptor.outputs.previous_version }}" \
          --arg new_version             "${{ needs.update-descriptor.outputs.new_version }}" \
          --rawfile updated_modules     /tmp/updated_modules.txt \
          --arg updated_cnt             "${{ needs.update-descriptor.outputs.updates_cnt }}" \
          --argjson updated             ${{ needs.update-descriptor.outputs.updated == 'true' }} \
          --rawfile failure_reason      /tmp/failure_reason.txt \
          --arg commit_sha              "${{ needs.commit-statefile.outputs.commit_sha }}" \
          --arg app_descriptor_file_name "${{ needs.update-descriptor.outputs.app_descriptor_file_name }}" \
          --arg app_descriptor_url      "$APP_DESCRIPTOR_URL" \
          '{
              application: $application,
              status: $status,
              previous_version: $previous_version,
              new_version: $new_version,
              updated_modules: $updated_modules,
              updated_cnt: $updated_cnt,
              updated: $updated,
              failure_reason: $failure_reason,
              commit_sha: $commit_sha,
              app_descriptor_file_name: $app_descriptor_file_name,
              app_descriptor_url: $app_descriptor_url
            }' > "/tmp/results/$APP_NAME.json"
      
          cat "/tmp/results/$APP_NAME.json"

      - name: Upload Application Result
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: "result-${{ inputs.app_name }}"
          path: "/tmp/results/${{ inputs.app_name }}.json"
          retention-days: 1
