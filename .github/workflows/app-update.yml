name: Application Update

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name'
        required: true
        type: string
      repo:
        description: 'Application repository name (org/repo format)'
        required: true
        type: string
      branch:
        description: 'Branch to update'
        required: false
        type: string
        default: 'snapshot'
      workflow_run_number:
        description: 'GitHub run number for display'
        required: true
        type: string
      descriptor_build_offset:
        description: 'Offset to apply to application artifact version'
        required: false
        type: number
        default: 100100000000000
      dry_run:
        description: 'Perform dry run without making changes'
        required: false
        type: boolean
        default: false
    outputs:
      app_name:
        description: 'Application name'
        value: ${{ inputs.app_name }}
      updated:
        description: 'Whether application was updated'
        value: ${{ jobs.update-descriptor.outputs.updated }}
      new_version:
        description: 'New application version if updated'
        value: ${{ jobs.update-descriptor.outputs.new_version }}
      # commit_sha:
      #   description: 'Commit SHA'
      #   value: ${{ jobs.snapshot-update.outputs.commit_sha }}

permissions:
  contents: write

env:
  STATE_FILE: "application-descriptor.json"
  PLATFORM_DESCRIPTOR: "platform-descriptor"
  APP_NAME: ${{ inputs.app_name }}

jobs:
  update-descriptor:
    name: Update Application Descriptor
    runs-on: ubuntu-latest
    outputs:
      updated_modules: ${{ steps.update-module-versions.outputs.updated_modules }}
      updated: ${{ steps.update-module-versions.outputs.updated }}
      updates_cnt: ${{ steps.update-module-versions.outputs.updates }}
      new_version: ${{ steps.update-application-version.outputs.new_version }}
      app_descriptor_file: ${{ steps.generate-application-descriptor.outputs.app_descriptor_file }}
    steps:
      - name: Checkout Application Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Previous Version
        id: collect-previous-version
        uses: folio-org/kitfox-github/.github/actions/collect-app-version@master
        with:
          app_name: ${{ inputs.repo }}
          branch: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Module Versions
        id: update-module-versions
        env:
          DOCKER_REGISTRY: "https://hub.docker.com/v2/repositories/folioci"
          NPM_REGISTRY: "https://repository.folio.org/repository/npm-folioci"
        run: |
          set -eo pipefail
          echo "::notice::Check for newer module versions"
          
          [[ -f $STATE_FILE ]] || { echo "::error::$STATE_FILE not found"; exit 1; }
          
          updated_modules=""
          updates=0
          
          while IFS=$'\t' read -r type module_name current_version; do
            echo "::group::Checking $type module: $module_name (current: $current_version)" 
            
            module_name_esc=$module_name
            
            if [[ "$type" != "backend" ]]; then
              module_name_esc="${module_name#folio_}" # Remove folio_ prefix
              module_name_esc="${module_name_esc//_/-}" # Replace _ with -
              [ "$type" = "ui" ] && module_name_esc="@folio/$module_name_esc" # Add @folio scope for UI modules
            
              module_name_esc="${module_name_esc//@/%40}" # Replace @ with %40
              module_name_esc="${module_name_esc//\//%2F}" # Replace / with %2F        
            fi
          
            if [[ "$type" == "backend" ]]; then
              image_path="${DOCKER_REGISTRY%/}/$module_name_esc/tags?ordering=last_updated"
              jq_filter='.results[]? | select(.name | test("-SNAPSHOT(\\.|-|$)")) | .name'
            else
              image_path="${NPM_REGISTRY%/}/$module_name_esc"
              jq_filter='."dist-tags".latest // empty'
            fi
                   
            echo "::notice::Fetching tags from $image_path"
            resp="$(curl -fsSL "$image_path" || true)"
            if [[ -z "$resp" ]]; then
              echo "::warning::Failed to fetch tags for $module_name"
              echo "::endgroup::"
              continue
            fi

            latest_version="$(echo "$resp" | jq -r "$jq_filter" | head -n1)"
            
            if [[ -n "$latest_version" && "$latest_version" != "$current_version" ]]; then
              echo "A new $type module version discovered: $module_name $current_version -> $latest_version"
          
              jq --arg name "$module_name" --arg version "$latest_version" '
                  .modules |= map(if .name == $name then .version = $version else . end)
                ' $STATE_FILE > temp.json && mv temp.json $STATE_FILE
              
              updated_modules+="$module_name $current_version -> $latest_version"$'\n'
              ((++updates))
            else
              echo "â†’ Up to date (no newer version found)"
            fi
            echo "::endgroup::"
          done <<< "$(jq -r '
            (.modules[]?    | ["backend",   .name, .version]),
            (.uiModules[]?  | ["ui", .name, .version])
            | @tsv
          ' $STATE_FILE)"

          
          echo "::notice::Found $updates module updates available"
          echo "updated=$([[ $updates -gt 0 ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "updates=$updates" >> "$GITHUB_OUTPUT"
          {
            echo 'updated_modules<<EOF'
            printf '%s' "$updated_modules"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Calculate New Version
        id: calculate-new-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          MAJOR: ${{ steps.collect-previous-version.outputs.major }}
          MINOR: ${{ steps.collect-previous-version.outputs.minor }}
          PATCH: ${{ steps.collect-previous-version.outputs.patch }}
          IS_SNAPSHOT: ${{ steps.collect-previous-version.outputs.is_snapshot }}
          RUN_NUMBER: ${{ inputs.workflow_run_number }}
          DESCRIPTOR_BUILD_OFFSET: ${{ inputs.descriptor_build_offset || 0 }}
        run: |
          set -eo pipefail
          echo "::notice::Calculate new version"

          if [[ "$IS_SNAPSHOT" == "true" ]]; then
            BUILD_NUMBER=$((DESCRIPTOR_BUILD_OFFSET + RUN_NUMBER))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-SNAPSHOT.${BUILD_NUMBER}"
          else
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          fi
          
          echo "::notice::Calculated new version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      - name: Update Application Version
        id: update-application-version
        if: steps.update-module-versions.outputs.updated == 'true'
        env:
          NEW_VERSION: ${{ steps.calculate-new-version.outputs.new_version }}
        run: |
          set -eo pipefail
          
          echo "::notice::Extracting current application version"
          PREVIOUS_VERSION=$(jq -r '.version' $STATE_FILE)
          echo "::notice::Current application version is $PREVIOUS_VERSION"
          
          echo "::notice::Update application version from $PREVIOUS_VERSION to $NEW_VERSION"          
          jq --arg version "$NEW_VERSION" '.version = $version' $STATE_FILE > temp.json && mv temp.json $STATE_FILE          
          echo "::notice::Updated application version to $NEW_VERSION"
          
          echo "updated=true" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "previous_version=$PREVIOUS_VERSION" >> "$GITHUB_OUTPUT"

      - name: Generate Application Descriptor
        id: generate-application-descriptor
        if: steps.update-application-version.outputs.updated == 'true'
        env:
          SUPRESS_LOGS: "-Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn"
          COMMAND: "org.folio:folio-application-generator:generateFromJson"
        run: |
          set -eo pipefail
                    
          if [[ ! -f "pom.xml" ]]; then
            echo "::error::pom.xml not found"
            exit 1
          fi
          
          echo "::notice:: Full Maven command: mvn $SUPRESS_LOGS clean $COMMAND -U -e -DtemplatePath=$STATE_FILE"
          echo "::group::Generate application artifact"
          mvn "$SUPRESS_LOGS" clean "$COMMAND" -U -e "-DtemplatePath=$STATE_FILE"
          echo "::endgroup::"
          
          echo "::group::Debug - Check target directory contents"
          ls -la target/ || echo "Target directory does not exist"
          echo "::endgroup::"
          
          APP_DESCRIPTOR_FILE=$(compgen -G "target/${APP_NAME}*.json" | head -n 1)
          if [[ -z "$APP_DESCRIPTOR_FILE" ]]; then
            echo "::error::Generated application descriptor not found"
            exit 1
          fi
          echo "::notice::Generated application descriptor file: $APP_DESCRIPTOR_FILE"
          echo "app_descriptor_file=$APP_DESCRIPTOR_FILE" >> "$GITHUB_OUTPUT"
          
          echo "::notice::Application artifact generated successfully"

      - name: Upload State File
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-state-file"
          path: ${{ env.STATE_FILE }}
          retention-days: 1

      - name: Upload Descriptor
        uses: actions/upload-artifact@v4
        if: steps.update-application-version.outputs.updated == 'true'
        with:
          name: "${{ env.APP_NAME }}-descriptor"
          path: "target/${{ env.APP_NAME }}*.json"
          retention-days: 1

  verify-publish-descriptor:
    name: Verify and Publish Updated Descriptor
    runs-on: ubuntu-latest
    needs: update-descriptor
    if: needs.update-descriptor.outputs.updated == 'true'
    steps:
      - name: Download Descriptor Artifact
        uses: actions/download-artifact@v4
        with:
          name: "${{ env.APP_NAME }}-descriptor"
          path: /tmp/app-descriptors

      - name: Download Platform Descriptor
        id: download-platform-descriptor
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PLATFORM_DESCRIPTOR }}
          path: /tmp/${{ env.PLATFORM_DESCRIPTOR }}

      - name: Fetch Application Descriptors from FAR
        id: fetch-app-descriptors
        env:
          FAR_API_URL: "https://far.ci.folio.org/applications"
        run: |
          set -eo pipefail
          echo "::notice::Fetch application descriptors from FAR for validation"

          [ ! -f "/tmp/$PLATFORM_DESCRIPTOR/$PLATFORM_DESCRIPTOR.json" ] && { echo "::error::Platform descriptor artifact not found"; exit 1; }

          cp /tmp/$PLATFORM_DESCRIPTOR/$PLATFORM_DESCRIPTOR.json ./$PLATFORM_DESCRIPTOR.json
          echo "::notice::Platform descriptor loaded successfully"

          mkdir -p /tmp/app-descriptors
          platform_apps=$(jq -c '
            [.applications.required[]?, .applications.optional[]?] 
            | map({name: .name, version: .version})
          ' platform-descriptor.json)

          app_count=$(echo "$platform_apps" | jq 'length')
          echo "::notice::Found $app_count applications in platform descriptor"
          
          echo "$platform_apps" | jq -c '.[]' | 
          while read -r app_entry; do
            app_name=$(echo "$app_entry" | jq -r '.name')
            app_version=$(echo "$app_entry" | jq -r '.version')
          
            [[ "$app_name" == "$APP_NAME" ]] && continue
            
            echo "Fetching descriptor for $app_name version $app_version..."
            
            descriptor_url="$FAR_API_URL/$app_name-$app_version?full=true"
            if descriptor=$(curl -sf "$descriptor_url" 2>/dev/null); then
              echo "$descriptor" > "/tmp/app-descriptors/${app_name}.json"
              echo "::notice:: Fetched $app_name"
            else
              echo "::error:: Could not fetch $app_name from FAR"
              exit 1
            fi
          done
          
          echo "::notice::Application descriptors fetched for validation"

      - name: Validate Application Module Interface Integrity
        id: validate-interfaces
        env:
          FAR_API_URL: "https://far.ci.folio.org/applications"
          APP_DESCRIPTOR_FILE: "/tmp/app-descriptors/${{ needs.update-descriptor.outputs.app_descriptor_file }}"
        run: |
          set -eo pipefail
          echo "::notice::Validate application module interface integrity"

          [ ! -f "$APP_DESCRIPTOR_FILE" ] && { echo "::error::Updated descriptor not found: $APP_DESCRIPTOR_FILE"; exit 1; }
          
          validation_response_and_code=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d "$(cat "$APP_DESCRIPTOR_FILE")" \
            "$FAR_API_URL/validate")
          
          validation_response=$(echo "$validation_response_and_code" | sed '$d')
          http_code=$(echo "$validation_response_and_code" | tail -n1)

          if ! [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
            echo "::error::Module interface integrity validation request failed (HTTP $http_code)"
            echo "::error::$validation_response"
            exit 1
          fi
          
          echo "::notice::Module interface integrity validation passed"

      - name: Validate Application Dependencies Integrity
        id: validate-dependencies
        env:
          FAR_API_URL: "https://far.ci.folio.org/applications"
        run: |
          set -eo pipefail
          echo "::notice::Validate application dependencies integrity"

          application_descriptors="[]"
          for descriptor_file in /tmp/app-descriptors/*.json; do
            [ -f "$descriptor_file" ] || continue
            descriptor=$(cat "$descriptor_file")
            application_descriptors=$(echo "$application_descriptors" | jq ". + [$descriptor]")
          done

          validation_response_and_code=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
            --argjson applicationDescriptors "$application_descriptors" \
            '{
              applicationDescriptors: $applicationDescriptors
            }')" \
            "$FAR_API_URL/validate-descriptors")

          validation_response=$(echo "$validation_response_and_code" | sed '$d')
          http_code=$(echo "$validation_response_and_code" | tail -n1)

          if ! [[ "$http_code" =~ ^2[0-9][0-9]$ ]]; then
            echo "::error::Dependencies integrity validation request failed (HTTP $http_code)"
            echo "::error::$validation_response"
            exit 1
          fi

          echo "::notice::Dependencies integrity validation passed"
#
#      - name: Upload to Application Registry
#        if: steps.update-modules.outputs.updated == 'true' && inputs.dry_run != true
#        env:
#          FAR_API_URL: "https://far.ci.folio.org/api/applications"
#        run: |
#          set -eo pipefail
#          echo "::group::Upload application to registry"
#
#          upload_response=$(curl -s -X POST \
#            -H "Content-Type: application/json" \
#            -d @target/application-descriptor.json \
#            "$FAR_API_URL" || echo '{"success":false}')
#
#          success=$(echo "$upload_response" | jq -r '.success // false')
#
#          if [[ "$success" != "true" ]]; then
#            echo "::error::Failed to upload application to registry"
#            echo "$upload_response" | jq -r '.message // "Unknown upload error"'
#            exit 1
#          fi
#
#          echo "::notice::Application uploaded to registry successfully"
#          echo "::endgroup::"
#
#      - name: Commit Changes
#        if: steps.update-modules.outputs.updated == 'true' && inputs.dry_run != true
#        env:
#          NEW_VERSION: ${{ steps.update-modules.outputs.new_version }}
#        run: |
#          set -eo pipefail
#          echo "::group::Commit updated application descriptor"
#
#          git config --global user.name "github-actions[bot]"
#          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
#
#          if git diff --quiet $STATE_FILE; then
#            echo "::notice::No changes to commit"
#            echo "::endgroup::"
#            exit 0
#          fi
#
#          git add $STATE_FILE
#          git commit -m "Update application snapshot to $NEW_VERSION" \
#            -m "Automated module version updates:" \
#            -m "- Backend modules: ${{ steps.check-versions.outputs.backend_updates }} updates" \
#            -m "- Frontend modules: ${{ steps.check-versions.outputs.frontend_updates }} updates" \
#            -m "Total modules updated: ${{ steps.check-versions.outputs.total_updates }}"
#
#          git push origin snapshot
#
#          echo "::notice::Changes committed and pushed to snapshot branch"
#          echo "::endgroup::"
#
#      - name: Report Results
#        if: always()
#        run: |
#          echo "::group::Snapshot update summary"
#
#          if [[ "${{ steps.check-versions.outputs.has_updates }}" == "true" ]]; then
#            if [[ "${{ inputs.dry_run }}" == "true" ]]; then
#              echo "::notice::DRY RUN: Would update ${{ steps.check-versions.outputs.total_updates }} modules"
#            else
#              echo "::notice::Successfully updated ${{ steps.check-versions.outputs.total_updates }} modules"
#              echo "::notice::New version: ${{ steps.update-modules.outputs.new_version }}"
#            fi
#          else
#            echo "::notice::No module updates available"
#          fi
#          echo "::endgroup::"
