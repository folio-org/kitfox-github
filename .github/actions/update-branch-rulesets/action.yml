# TODO: Specify branch ruleset parameters in the update-config.yml file later and update it here based on them.
name: 'Update Branch Rulesets'
description: 'Create or update branch rulesets with merge queue and required status checks'

inputs:
  repository:
    description: 'Repository in owner/repo format'
    required: true
  branches:
    description: 'JSON array of branch names to configure rulesets for'
    required: true
  ruleset_pattern:
    description: 'Pattern for ruleset names with {0} as branch placeholder (e.g., eureka-ci-{0} or {0}-merge-queue)'
    required: false
    default: '{0}-eureka-ci'
  required_check:
    description: 'Required status check context name'
    required: false
    default: 'eureka-ci / validate-application'
  check_integration_id:
    description: 'Integration ID for the status check source (GitHub App ID)'
    required: false
    default: '1671958' # TODO: Move it to a kitfox-github env variable later
  branch_config:
    description: 'JSON array of branch configurations with need_pr flag'
    required: false
    default: '[]'
  github_token:
    description: 'GitHub token with admin permissions'
    required: true

outputs:
  branches_updated:
    description: 'Comma-separated list of branches that were updated'
    value: ${{ steps.update.outputs.branches_updated }}
  branches_skipped:
    description: 'Comma-separated list of branches that were skipped'
    value: ${{ steps.update.outputs.branches_skipped }}
  branches_failed:
    description: 'Comma-separated list of branches that failed'
    value: ${{ steps.update.outputs.branches_failed }}

runs:
  using: 'composite'
  steps:
    - name: Update Branch Rulesets
      id: update
      uses: actions/github-script@v7
      env:
        INPUT_REPOSITORY: ${{ inputs.repository }}
        INPUT_BRANCHES: ${{ inputs.branches }}
        INPUT_REQUIRED_CHECK: ${{ inputs.required_check }}
        INPUT_CHECK_INTEGRATION_ID: ${{ inputs.check_integration_id }}
        INPUT_BRANCH_CONFIG: ${{ inputs.branch_config }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const [owner, repo] = process.env.INPUT_REPOSITORY.split('/');
          const branches = JSON.parse(process.env.INPUT_BRANCHES);
          const requiredCheck = process.env.INPUT_REQUIRED_CHECK;
          const branchConfig = JSON.parse(process.env.INPUT_BRANCH_CONFIG || '[]');
          const checkIntegrationId = parseInt(process.env.INPUT_CHECK_INTEGRATION_ID, 10);

          const updatedBranches = [];
          const skippedBranches = [];
          const failedBranches = [];

          console.log(`Processing ${branches.length} branches for ${owner}/${repo}`);
          console.log(`Required check: ${requiredCheck}`);
          console.log(`Branch config entries: ${branchConfig.length}`);

          let existingRulesets = [];
          try {
            const { data: rulesets } = await github.rest.repos.getRepoRulesets({
              owner,
              repo,
              includes_parents: false
            });
            existingRulesets = rulesets;
            console.log(`Found ${existingRulesets.length} existing rulesets`);
          } catch (error) {
            console.log(`Note: Could not fetch existing rulesets: ${error.message}`);
          }

          for (const branch of branches) {
            const rulesetName = '${{ inputs.ruleset_pattern }}'.replace('{0}', branch);
            console.log(`\nProcessing branch: ${branch}, ruleset: ${rulesetName}`);

            try {
              await github.rest.repos.getBranch({
                owner,
                repo,
                branch
              });
            } catch (error) {
              if (error.status === 404) {
                console.log(`Branch ${branch} does not exist, skipping`);
                skippedBranches.push(`${branch} (not found)`);
                continue;
              }
              throw error;
            }

            const config = branchConfig.find(c => c.branch === branch) || {};
            const needPr = config.need_pr === true;
            console.log(`Branch ${branch}: need_pr=${needPr}`);

            const rules = [];

            rules.push({
              type: 'required_status_checks',
              parameters: {
                required_status_checks: [
                  {
                    context: requiredCheck,
                    integration_id: checkIntegrationId
                  }
                ],
                strict_required_status_checks_policy: false
              }
            });

            if (needPr) {
              rules.push({
                type: 'merge_queue',
                parameters: {
                  check_response_timeout_minutes: 60,
                  grouping_strategy: 'ALLGREEN',
                  max_entries_to_build: 5,
                  max_entries_to_merge: 5,
                  merge_method: 'SQUASH',
                  min_entries_to_merge: 1,
                  min_entries_to_merge_wait_minutes: 5
                }
              });
            }

            const rulesetConfig = {
              name: rulesetName,
              target: 'branch',
              enforcement: 'active',
              conditions: {
                ref_name: {
                  include: [`refs/heads/${branch}`],
                  exclude: []
                }
              },
              rules: rules,
              bypass_actors: [
                {
                  actor_id: 1671958,
                  actor_type: 'Integration',
                  bypass_mode: 'always'
                }
              ]
            };

            try {
              const existingRuleset = existingRulesets.find(r => r.name === rulesetName);

              if (existingRuleset) {
                console.log(`Updating existing ruleset: ${rulesetName} (ID: ${existingRuleset.id})`);
                await github.rest.repos.updateRepoRuleset({
                  owner,
                  repo,
                  ruleset_id: existingRuleset.id,
                  ...rulesetConfig
                });
                updatedBranches.push(`${branch} (updated)`);
              } else {
                console.log(`Creating new ruleset: ${rulesetName}`);
                await github.rest.repos.createRepoRuleset({
                  owner,
                  repo,
                  ...rulesetConfig
                });
                updatedBranches.push(`${branch} (created)`);
              }
            } catch (error) {
              console.error(`Error processing branch ${branch}: ${error.message}`);
              failedBranches.push(`${branch}: ${error.message}`);
            }
          }

          core.setOutput('branches_updated', updatedBranches.join(', ') || 'none');
          core.setOutput('branches_skipped', skippedBranches.join(', ') || 'none');
          core.setOutput('branches_failed', failedBranches.join(', ') || 'none');

          console.log(`\nSummary:`);
          console.log(`- Updated: ${updatedBranches.length}`);
          console.log(`- Skipped: ${skippedBranches.length}`);
          console.log(`- Failed: ${failedBranches.length}`);

          if (failedBranches.length > 0) {
            core.setFailed(`Failed to update rulesets for: ${failedBranches.join(', ')}`);
          }