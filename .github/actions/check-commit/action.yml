name: 'Check Commit'
description: 'Validate application commit with check run management and protected file checks'

inputs:
  repo_owner:
    description: 'Repository owner'
    required: true
  repo_name:
    description: 'Repository name'
    required: true
  head_sha:
    description: 'Commit SHA to validate'
    required: true
  base_branch:
    description: 'Target branch for platform descriptor'
    required: true
  github_token:
    description: 'GitHub token with checks:write permission'
    required: true
  check_type:
    description: 'Check type for messaging (pr or merge_queue)'
    required: false
    default: 'pr'
  pr_number:
    description: 'PR number (for PR context messaging)'
    required: false
    default: ''
  head_branch:
    description: 'Head branch name (for PR context messaging)'
    required: false
    default: ''
  far_url:
    description: 'FAR API URL base'
    required: true
  workflow_run_url:
    description: 'URL to the workflow run for details link'
    required: true

outputs:
  validation_passed:
    description: 'Whether validation passed'
    value: ${{ steps.validate.outputs.validation_passed }}
  failure_reason:
    description: 'Reason for failure'
    value: ${{ steps.check-descriptor.outputs.exists != 'true' && steps.check-descriptor.outputs.failure_reason || steps.check-protected.outputs.has_violation == 'true' && steps.check-protected.outputs.violation_reason || steps.validate.outputs.failure_reason || 'Check workflow logs for details' }}
  check_run_id:
    description: 'Created check run ID'
    value: ${{ steps.create-check.outputs.check_run_id }}
  descriptor_exists:
    description: 'Whether descriptor file exists'
    value: ${{ steps.check-descriptor.outputs.exists }}
  platform_found:
    description: 'Whether platform descriptor was found'
    value: ${{ steps.fetch-platform.outputs.platform_found }}
  protected_file_violation:
    description: 'Whether protected files were violated'
    value: ${{ steps.check-protected.outputs.has_violation }}

runs:
  using: 'composite'
  steps:
    - name: Create Check Run
      id: create-check
      uses: actions/github-script@v7
      env:
        CHECK_TYPE: ${{ inputs.check_type }}
        PR_NUMBER: ${{ inputs.pr_number }}
        REPO_OWNER: ${{ inputs.repo_owner }}
        REPO_NAME: ${{ inputs.repo_name }}
        HEAD_SHA: ${{ inputs.head_sha }}
        WORKFLOW_RUN_URL: ${{ inputs.workflow_run_url }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const checkType = process.env.CHECK_TYPE;
          const prNumber = process.env.PR_NUMBER;
          const repoOwner = process.env.REPO_OWNER;
          const repoName = process.env.REPO_NAME;

          const summary = checkType === 'merge_queue'
            ? 'Starting merge queue validation...'
            : `Starting application verification for PR #${prNumber}...`;

          const detailsUrl = checkType === 'merge_queue'
            ? process.env.WORKFLOW_RUN_URL
            : `https://github.com/${repoOwner}/${repoName}/pull/${prNumber}`;

          const { data: checkRun } = await github.rest.checks.create({
            owner: repoOwner,
            repo: repoName,
            name: 'eureka-ci / validate-application',
            head_sha: process.env.HEAD_SHA,
            status: 'in_progress',
            started_at: new Date().toISOString(),
            output: {
              title: 'Application Verification',
              summary: summary
            },
            details_url: detailsUrl
          });

          console.log(`Created check run with ID: ${checkRun.id}`);
          core.setOutput('check_run_id', checkRun.id);

    - name: Check Existing Descriptor
      id: check-descriptor
      shell: bash
      env:
        DESCRIPTOR_FILE: "application.lock.json"
      run: |
        set -eo pipefail

        if [[ ! -f "$DESCRIPTOR_FILE" ]]; then
          echo "::error::Application descriptor not found: $DESCRIPTOR_FILE"
          echo "exists=false" >> "$GITHUB_OUTPUT"
          echo "failure_reason=Application descriptor file not found: $DESCRIPTOR_FILE" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "::notice::Found existing application descriptor: $DESCRIPTOR_FILE"
        echo "exists=true" >> "$GITHUB_OUTPUT"
        echo "descriptor_file=$DESCRIPTOR_FILE" >> "$GITHUB_OUTPUT"

    - name: Check Protected Files
      id: check-protected
      if: steps.check-descriptor.outputs.exists == 'true'
      shell: bash
      env:
        CHECK_TYPE: ${{ inputs.check_type }}
        PR_NUMBER: ${{ inputs.pr_number }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
        REPO_OWNER: ${{ inputs.repo_owner }}
        REPO_NAME: ${{ inputs.repo_name }}
      run: |
        set -eo pipefail
        violations=""

        if [[ "$CHECK_TYPE" == "merge_queue" ]]; then
          if git diff --name-status HEAD~1 HEAD 2>/dev/null | grep -E "^D.*application\.template\.json$"; then
            violations="application.template.json: template file deletion not allowed"
          fi
        else
          files=$(gh api "repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/files" --jq '.[] | select(.status == "removed") | .filename' 2>/dev/null || true)
          if echo "$files" | grep -q "application.template.json"; then
            violations="application.template.json: template file deletion not allowed"
          fi
        fi

        if [[ -n "$violations" ]]; then
          echo "::error::Protected file violation: $violations"
          echo "has_violation=true" >> "$GITHUB_OUTPUT"
          echo "violation_reason=$violations" >> "$GITHUB_OUTPUT"
        else
          echo "has_violation=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Fetch Platform Descriptor
      id: fetch-platform
      if: steps.check-descriptor.outputs.exists == 'true'
      shell: bash
      env:
        BRANCH: ${{ inputs.base_branch }}
      run: |
        set -eo pipefail
        mkdir -p /tmp/platform

        echo "::notice::Fetching platform descriptor from platform-lsp branch: $BRANCH"

        http_code=$(curl -sS -w "%{http_code}" -o /tmp/platform/platform-descriptor.json \
          "https://raw.githubusercontent.com/folio-org/platform-lsp/$BRANCH/platform-descriptor.json")

        if [ "$http_code" = "200" ]; then
          echo "::notice::Platform descriptor fetched successfully from branch: $BRANCH"
          echo "platform_found=true" >> "$GITHUB_OUTPUT"
          echo "platform_descriptor_path=/tmp/platform/platform-descriptor.json" >> "$GITHUB_OUTPUT"
        elif [ "$http_code" = "404" ]; then
          echo "::warning::Platform descriptor not found for branch $BRANCH (HTTP 404)"
          echo "::warning::Dependency validation will be skipped"
          echo "platform_found=false" >> "$GITHUB_OUTPUT"
        else
          echo "::error::Failed to fetch platform descriptor from branch $BRANCH (HTTP $http_code)"
          echo "::error::This might be a temporary issue. Please retry the check."
          echo "platform_found=false" >> "$GITHUB_OUTPUT"
          echo "fetch_error=true" >> "$GITHUB_OUTPUT"
          exit 1
        fi

    - name: Update Check Run - Validating
      if: steps.check-descriptor.outputs.exists == 'true'
      uses: actions/github-script@v7
      env:
        REPO_OWNER: ${{ inputs.repo_owner }}
        REPO_NAME: ${{ inputs.repo_name }}
        CHECK_RUN_ID: ${{ steps.create-check.outputs.check_run_id }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          await github.rest.checks.update({
            owner: process.env.REPO_OWNER,
            repo: process.env.REPO_NAME,
            check_run_id: parseInt(process.env.CHECK_RUN_ID),
            status: 'in_progress',
            output: {
              title: 'Application Verification',
              summary: 'Validating application descriptor and dependencies...'
            }
          });

    - name: Validate Application
      id: validate
      if: steps.check-descriptor.outputs.exists == 'true'
      uses: folio-org/kitfox-github/.github/actions/validate-application@master
      with:
        app_name: ${{ inputs.repo_name }}
        app_descriptor_path: ${{ steps.check-descriptor.outputs.descriptor_file }}
        platform_descriptor_path: ${{ steps.fetch-platform.outputs.platform_descriptor_path }}
        use_platform_descriptor: ${{ steps.fetch-platform.outputs.platform_found == 'true' && 'true' || 'false' }}
        rely_on_FAR: 'false'
        far_url: ${{ inputs.far_url }}

    - name: Finalize Check Run
      if: always()
      uses: actions/github-script@v7
      env:
        CHECK_TYPE: ${{ inputs.check_type }}
        PR_NUMBER: ${{ inputs.pr_number }}
        HEAD_BRANCH: ${{ inputs.head_branch }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        HEAD_SHA: ${{ inputs.head_sha }}
        REPO_OWNER: ${{ inputs.repo_owner }}
        REPO_NAME: ${{ inputs.repo_name }}
        CHECK_RUN_ID: ${{ steps.create-check.outputs.check_run_id }}
        WORKFLOW_RUN_URL: ${{ inputs.workflow_run_url }}
        DESCRIPTOR_EXISTS: ${{ steps.check-descriptor.outputs.exists }}
        DESCRIPTOR_FAILURE_REASON: ${{ steps.check-descriptor.outputs.failure_reason }}
        VALIDATION_PASSED: ${{ steps.validate.outputs.validation_passed }}
        FAILURE_REASON: ${{ steps.validate.outputs.failure_reason }}
        PLATFORM_FOUND: ${{ steps.fetch-platform.outputs.platform_found }}
        FETCH_ERROR: ${{ steps.fetch-platform.outputs.fetch_error }}
        FETCH_OUTCOME: ${{ steps.fetch-platform.outcome }}
        PROTECTED_VIOLATION: ${{ steps.check-protected.outputs.has_violation }}
        PROTECTED_VIOLATION_REASON: ${{ steps.check-protected.outputs.violation_reason }}
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const checkType = process.env.CHECK_TYPE;
          const prNumber = process.env.PR_NUMBER;
          const headBranch = process.env.HEAD_BRANCH;
          const baseBranch = process.env.BASE_BRANCH;
          const headSha = process.env.HEAD_SHA;
          const repoOwner = process.env.REPO_OWNER;
          const repoName = process.env.REPO_NAME;

          const descriptorExists = process.env.DESCRIPTOR_EXISTS;
          const descriptorFailureReason = process.env.DESCRIPTOR_FAILURE_REASON;
          const validationPassed = process.env.VALIDATION_PASSED;
          const failureReason = process.env.FAILURE_REASON;
          const platformFound = process.env.PLATFORM_FOUND;
          const fetchError = process.env.FETCH_ERROR;
          const fetchOutcome = process.env.FETCH_OUTCOME;
          const protectedViolation = process.env.PROTECTED_VIOLATION;
          const protectedViolationReason = process.env.PROTECTED_VIOLATION_REASON;

          let conclusion, title, summary;

          if (descriptorExists !== 'true') {
            conclusion = 'failure';
            title = 'Descriptor Not Found';
            summary = descriptorFailureReason || 'Application descriptor file not found';
          } else if (fetchError === 'true' || fetchOutcome === 'failure') {
            conclusion = 'failure';
            title = 'Platform Descriptor Fetch Failed';
            summary = `Failed to fetch platform descriptor from branch ${baseBranch}. This might be a temporary issue. Please retry.`;
          } else if (protectedViolation === 'true') {
            conclusion = 'failure';
            title = 'Protected File Violation';
            summary = protectedViolationReason || 'Protected file modification detected';
          } else if (validationPassed === 'false') {
            conclusion = 'failure';
            title = 'Verification Failed';
            summary = failureReason || 'Application verification failed. Check the logs for details.';
          } else if (validationPassed === 'true') {
            conclusion = 'success';
            title = 'All Checks Passed';
            summary = platformFound === 'false'
              ? 'Application verification completed successfully (dependency validation skipped - platform descriptor not found)'
              : 'Application verification completed successfully';
          } else {
            conclusion = 'neutral';
            title = 'Check Incomplete';
            summary = 'Some checks could not be completed';
          }

          const contextInfo = checkType === 'merge_queue'
            ? `**Merge Queue Validation**\n**Target Branch:** \`${baseBranch}\``
            : `**Pull Request:** [#${prNumber}](https://github.com/${repoOwner}/${repoName}/pull/${prNumber})\n**Branch:** \`${headBranch}\``;

          let verificationSection = '';
          if (descriptorExists === 'true') {
            verificationSection = `
          ### Application Verification
          - **Passed:** ${validationPassed || 'unknown'}
          ${failureReason ? `- **Reason:** ${failureReason}` : ''}`;
          }

          let protectedSection = '';
          if (protectedViolation === 'true') {
            protectedSection = `
          ### Protected File Violation
          - **Reason:** ${protectedViolationReason}`;
          }

          const text = `
          ## Application Verification Results

          ${contextInfo}
          **Commit:** \`${headSha}\`

          ### Descriptor Status
          - **Found:** ${descriptorExists || 'false'}
          ${protectedSection}
          ${verificationSection}

          ### Workflow Run
          - **URL:** ${process.env.WORKFLOW_RUN_URL}
          `;

          const updateParams = {
            owner: repoOwner,
            repo: repoName,
            check_run_id: parseInt(process.env.CHECK_RUN_ID),
            status: 'completed',
            conclusion: conclusion,
            completed_at: new Date().toISOString(),
            output: {
              title: title,
              summary: summary,
              text: text
            },
            details_url: process.env.WORKFLOW_RUN_URL
          };

          if (descriptorExists !== 'true' || fetchError === 'true' || protectedViolation === 'true' || validationPassed === 'false') {
            updateParams.actions = [{
              label: 'Re-run Validation',
              description: 'Trigger a new validation check',
              identifier: 're-run-validation'
            }];
          }

          await github.rest.checks.update(updateParams);
          console.log(`Check run finalized with conclusion: ${conclusion}`);

          if (conclusion === 'failure') {
            core.setFailed(summary);
          }
